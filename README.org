* Updating parameters





Your data is a plist (property list). To retrieve values by key from it, use the =plist-get= function in Emacs Lisp.

Example assuming your data is bound to a variable =params=:

#+begin_src emacs-lisp
(plist-get params :name)           ; => "kanban"
(plist-get params :mirrored)       ; => t
(plist-get params :indentation-column) ; => 0
(plist-get params :content)        ; => the table content string with text properties
#+end_src

If you have the entire plist inline, you can assign it first:

#+begin_src emacs-lisp
(setq params '(:name "kanban" :mirrored t :indentation-column 0 :content "..."))
#+end_src

Then use =plist-get= to fetch the values by their keys as shown above.

So the parameters are all the content including the parameters are there.


* Check out

* Feature configure
:PROPERTIES:
:ID:       a720c84b-4780-46e5-b426-1aa8526d805d
:END:
So i want an option to be able to choose a specfic kanban board.
The search for the kanban board and get back the heading

$f::list[kboard]$



To store metadata about positions and headings in an org document, both property lists (plists) and structs can work in Emacs Lisp. Here are considerations:

- *Plists:* Flexible, dynamic keys, easy for quick ad-hoc storage.
- *Structs:* Define fixed fields, better for structured data and type safety.

For your use case (storing position, heading, etc. found after an org-dblock), a plist usually suffices and is simpler:

#+begin_src elisp
;; Example plist for a kanban board entry
(setq kboard-entry '(:position 123 :heading "Feature configure"))
#+end_src

You can collect these in a list:

#+begin_src elisp
(setq kboard-entries (list kboard-entry))
#+end_src

When you search your org buffer, for example with =org-element= API, you can grab positions and headings, then store them in plists like above.

If later you want to enforce structure, define a =cl-defstruct= for a board item:

#+begin_src elisp
(cl-defstruct kboard-entry
  position
  heading)
#+end_src

But starting with plists is simpler and idiomatic for Emacs Lisp.

---

*Example to get heading at point:*

#+begin_src elisp
(defun my/org-get-heading-at-pos (pos)
  (save-excursion
    (goto-char pos)
    (org-get-heading t t t t)))
#+end_src

Then store =(list :position pos :heading (my/org-get-heading-at-pos pos))= per found block.

---

If you want I can help write code to parse the buffer for those dblocks and store the info.



In Emacs Lisp, a plist is a simple key-value list like =(:key1 val1 :key2 val2)=. To get a property, use =plist-get=:
#+begin_src elisp
(plist-get kboard :heading)  ;; retrieves the value for :heading from kboard plist
#+end_src

Yes, conceptually a plist works like a hash map with keys and values, but keys are typically keywords (symbols starting with =:=) and you must search sequentially, so it’s less efficient than a hash table but very idiomatic and convenient for most uses.

For your kanban board, you might store entries like:
#+begin_src elisp
(setq kboard '(:position 123 :heading "Feature configure"))
(plist-get kboard :heading)  ;; => "Feature configure"
#+end_src

If you want to collect many entries, use a list of plists:
#+begin_src elisp
(setq kboards (list kboard ...))
#+end_src

You can search your org buffer for kanban headings and store them in such plists. If you want, I can help write code to do that.



** Finding all kanban boards

The idea is to search in the document for all the kanban-boards


this can be done using  =(kanban-search-forward-for-board)= .

1. sending in (point-min) we get to the start , then the fn will return first point.
   2. Using a lambda can we make use of closure?
      For example if we capture a plist and add to it, let me try.

#+begin_src emacs-lisp :transient t
  (defun capture-list-test (ref-list)
    "docstring"
    (lambda (val)
      (nconc ref-list (list val))
      ))

  (defun call-cap-for-list ()
    "docstring"
    (interactive)
    (let* (
           (my-list (list "a" "b"))
           (my-fn (capture-list-test my-list))
           )
      (progn
        (mapcar my-fn '("a" "b" "c"))
        my-list
        )))
#+end_src

#+RESULTS:
: call-cap-for-list


Good experiment!
However, in your code, the lambda closes over =ref-list=, but =nconc= does *not* alter =my-list= in =call-cap-for-list= as you might expect.

That’s because in Emacs Lisp (like most Lisps), =nconc= mutates /the last cons cell/ of its first argument (the list’s cdr), but since you passed =(list "a" "b")=, =my-list= is a fresh list each function call, and the closure does not update it in place for the outside scope. The closure just keeps its own reference.

*To actually capture changes, you should use a single mutable /data structure/, e.g. a list placed in a variable by reference. Or use =list= cell tricks.* For example:

#+begin_src elisp :lexical t
  (defun capture-list-test (ref-cell)
    (lambda (val)
      (setcdr ref-cell (append (cdr ref-cell) (list val)))))

  (defun call-cap-for-list ()
    (interactive)
    (let* ((my-list (list "d")) ; dummy head cell
           (my-fn (capture-list-test my-list)))
      (mapcar my-fn '("a" "b" "c"))
      (cdr my-list)
      ))
  ;; call-cap-for-list => ("a" "b" "c")
#+end_src

#+RESULTS:
: call-cap-for-list

In essence , i will create a list.
With points , where i can find the different kanban board in a file.

I have a function =kanban-search-forward-for-board=
which needs a pt and name and a fn.
If that function is

#+begin_src emacs-lisp :lexical t
  (defun store-points-fn (list-of-points)
    "Returns another function that stores points"
    (lambda ()
      (setcdr list-of-points (append (cdr list-of-points) (list (point))))
      ))



  (defun kanban-search-forward-for-board (pt name fn)
    "search forward for the dynamic board "
    (let* ((board-regexp (format "^#\\+BEGIN: %s" name)))
      (goto-char pt)
      (when (re-search-forward board-regexp nil t)
        (goto-char (match-beginning 0))
        (funcall fn)
        (point))))
#+end_src

#+RESULTS:
: kanban-search-forward-for-board

Now using =kanban-search-forward-for-board=

#+begin_src emacs-lisp :lexical t
  (progn
    (let* ((my-list (list nil))
           (store-fn (store-points-fn my-list))
           )
      (kanban-search-forward-for-board (point-min) "kanban" store-fn)
      my-list
      )
    )
#+end_src

#+RESULTS:
| nil | 25511 |

THis is exactly what i was hoping for.  Now to further extend this, we
will need to loop through the available places, fortunatly we ave a
=kanban-exec-fn-all-boards=, if we use this together with our newly
created function, we should have a list of all

#+begin_src emacs-lisp :lexical
  (let* ((my-list (list nil))
         (store-fn (store-points-fn my-list))
         )
    (progn
      (kanban-exec-fn-all-blocks store-fn)
      (cdr my-list)
    ))

#+end_src

#+RESULTS:
| 25928 | 26493 |
 YES! That work perfectly
Now this should be implemented in =kanban-find-boards=

(kanban-find-boards)


#+NAME: TEST
#+BEGIN: kanban :mirrored t :match calle :mirror nil
| DONE                   | TODO                                |
|------------------------+-------------------------------------|
| [[file:README.org::*Jump to board (suffix)][Jump to board (suffix)]] |                                     |
|                        | [[file:README.org::*add the heading to choices.][add the heading to choices.]]         |
|                        | [[file:README.org::*org element at point][org element at point]]                |
|                        | [[file:README.org::*Adding match property][Adding match property]]               |
|                        | [[file:README.org::*Making a inifix with board names...][Making a inifix with board names...]] |
#+END:





So what do we want to do with this? Well the idea is to
be able to refer to one (if there are several). Right now i only have their position.
But maybe they have a name? or do i want to add a name?
I want to choose which I want to jump to?
At this  point we can use =org-element-at-point= which returns the properties (and name)


** DONE Jump to board (suffix)
CLOSED: [2025-08-07 Thu 21:38]
Should be fairly easy to implement a interactive jump to a
position now..

So lets say we create a suffix, with choices, these choices are
obviously gotten from =kanban-find-boards= where we get a list of positions?

Maybe its I can use =competing-read=
lets try it out. =kanban-find-boards= returns a list of position.
This list needs first to be transformed to strings...




#+begin_src emacs-lisp :lexical
  (defun kanban-jump-to-position ()
  "Interactively jump to a kanban board position."
  (interactive)
  (let* ((positions (kanban-find-boards))            ; e.g. a list of symbols or numbers
         (candidates (mapcar #'prin1-to-string positions))
         (choice (completing-read "Jump to board: " candidates)))
    (goto-char (string-to-number choice))
    ))
#+end_src

This is all good and cozy, the only problem is that it looks awful.
At least i can do is use "board 1" "board 2" ..
For that we need a plist...

Lets first check out how this can be done
#+begin_src emacs-lisp :lexical
  (defun kanban-make-alist (board-number pos)
    "Create alist with number and position"
    (let ((linenr (line-number-at-pos pos)))
      (cons (format "Board #%d (line %d)" board-number linenr) pos)
    ))

  (defun kanban-create-seq (candidates)
    "create a sequence of all candidates"
    (number-sequence 1 (length candidates))
    )


  (defun kanban-jump-to-board ()
    "docstring"
    (interactive)
    (let* ((positions (kanban-find-boards)) ;Here we get all the position
           (candidates (cl-mapcar #'kanban-make-alist (kanban-create-seq positions) positions))

           (choice (completing-read "Jump to board" (mapcar #'car candidates)))
           (pos (cdr (assoc choice candidates)))
           )
      (message "Pos %d" pos)
      (goto-char pos)
      ))

(org-get-heading)
#+end_src

#+RESULTS:
: TODO Jump to board (suffix)

one slight change to this is to to have the org heading..
That would be pretty cool.. That has to wait..


*** TODO add the heading to choices.

** TODO org element at point
As described above we could get the element at point and retrive some useful information
I would also like to get the line number for a point.
=(line-number-at-pos 25928)= i.e
So instead of reffering to name (if it dont exists) i can refer to a line number.

To get the right board, to be able to change it, we first need to get
our point to the right place. No worries, thats the easy part




** DONE Adding match property                                     :something:
CLOSED: [2025-09-05 fre 10:36]

When I press apply, i will first see which infix are selected.
Each infix (e.g match, or mirror) are associated with a update function.
 - mirror :: =kanban--update-mirror-property=
 - match :: =kanban--update-match-property=

 The problem is the =kanban--update-board-property= at this moment, its more
 for mirror property,

 The regexp need to be updated =(format ":%s\\s-+\\(?:t\\|nil\\)"= actually it should be an argument


#+begin_src emacs-lisp
  (let* ((board (car (last (kanban-find-boards))))
         (prop-regex ":mirrored\\s-+\\(?:t\\|nil\\)")
         )
    (kanban--update-board-property board "match" "hello" prop-regex)

    )
#+end_src

#+RESULTS:

Instead of sending what to match , and value
If we send in a  function. This way we can do what ever we want.

 1. We got to the char position.
 2. Check that we are at the begnning.
 3. Now we send the hole row except for =#+BEGIN: kanban=
 4. The function can now do what ever it likes and return the new parameter line




#+begin_src emacs-lisp
  (defun test-re-organize (params)
    "docstring"
    (format ":mirror t :match %s" "apa"))

  (defun kanban--update-board-property2 (pos fn)
    "Update PROPERTY with VALUE for board at POS."
    (save-excursion
      (goto-char pos)
      (when (looking-at "#\\+BEGIN: kanban\\(.*\\)$")
        (let* ((params (match-string 1))
               (properties (funcall fn params))
               )
            (beginning-of-line)
            (kill-line)
            (insert "\n")
            (previous-line)
            (insert (format "#+BEGIN: kanban %s" properties ))))))



  (kanban--update-board-property2 (car (last (kanban-find-boards))) #'test-re-organize)
#+end_src

#+RESULTS:




** DONE Property update
CLOSED: [2025-09-05 fre 10:35]
#+begin_src emacs-lisp :lexical t
  (defun kanban-replace-property (property new-val)
    "Creates a closure with new-val that replaces the old"
    (lambda (prop-arg)
      (let* (
             (regexp (format ":%s[ \t]+[^ ]+" property))
             (new-prop (format ":%s %s" property new-val) ))
        (replace-regexp-in-string regexp new-prop prop-arg)
        )))


  (let* ((fn (kanban-replace-mirror "match" "calle")))
    (funcall fn "kanban :mirror t :match apa")
    )

#+end_src

Whats missing is a =suffix= that decides which /function/ and /board/ to update
The function is decided which /infix/ are changed, or maybe all of them based on

We can make a ALIST of the argument value and the property

#+begin_src emacs-lisp :lexical t
  (defconst kanban-property-switches
  '(("mirror" . "--mirrored=")
    ("match"   . "--match="))
  "Alist mapping names to switches.")

  (defun kanban-get-value-from-alist (key)
    " Simple function to just get the value from a key"
    (cdr (assoc key kanban-property-switches)))


  (defun kanban-get-property-fn (property-name)
    "docstring"
    (let* ((switch (kanban-get-value-from-alist property-name))
           (mirror-value (transient-arg-value switch (transient-args 'kanban-properties)))
           (function (kanban-replace-property property-name mirror-value))
      )
      function
    ))



  (transient-define-suffix kanban--apply-properties()
    "Apply the new property based on Infix and boards"
    :description "Apply"
    :key "A"                  ;; Key to trigger this suffix
    (interactive )
    (let* ((args (transient-args 'kanban-properties))
           (mirror-value (transient-arg-value "--option=" args))
           (mirror-fn (kanban-replace-mirror))
           )
      (message "Value %s" value)
      ))

#+end_src

This works for the different match and mirror, all we need is to provide the property-name (match,mirror),
But to update all we need to iterate through each if the Alist.

This want work since i need to return the fixed string.
#+begin_src emacs-lisp :lexical
  (defun kanban-replace-property-header (property-header)
    "docstring"
    (let* ((properties (mapcar #'car kanban-property-switches))
           (fns (mapcar #'kanban-get-property-fn properties))
         )
    (cl-dolist (fn fns)
      (funcall fn ":mirror t :match apa")
      )))
#+end_src

#+RESULTS:

Allright, back in buisness.  So we have something that could update
once we are at the selected board.

[[file:kanban-transient.el::defun kanban-update-board-property (args][Kanban-update-board-property]]
 1. Get all the boards =kanban-find-boards=
 3. For each of the board
    1. [ ] Get the function-list of all property update functions =kanban-get-property-fn= ,
    2. [ ] Jump to the position for that board.
    3. [ ] For each of the property fn
       1. [ ] apply it.

First I need to iterate (mapcar) through each of the =selected-boards=
At the same time i need all the fns, for each.
So I can create a new lambda function which /handles/ each board.
Actually to make this better , we can jump to the position

#+begin_src emacs-lisp :lexical t
  (defun kanban-update-board-property (selected-list)
    "docstring"
    (let* ((prop-fns (kanban--get-property-fns)))
      (mapcar (lambda (board-pos)
                (kanban--update-position-with-fns pos prop-fns)
                ) selected-list)
      ))

#+end_src

The problem is that =prop-fns= is a list, we need to make it one =fn=

#+begin_src emacs-lisp :lexical t
  (defun kanban--update-position-with-fns (pos fns)
    "For each of the fns update using kanban--update-board-property2"
    (mapcar (lambda (fn)
              (kanban--update-board-property2 pos fn)
              ) fns))
#+end_src

Now we need to create a suffix.
that takes care of the selected list.

#+begin_src emacs-lisp :lexical t
  (transient-define-suffix kanban-apply-property-update()
    "Documentation string"
    :description "Apply selected"
    :key "P"                  ;; Key to trigger this suffix
    (interactive )
    (kanban-update-board-property kanban--selected-boards))


#+end_src

#+begin_example
tl;dr

- Problem: (transient-args 'kanban-properties) was returning defaults ("--mirrored=nil") because you were calling it outside the active transient session (or too late), so transient only had default values.
- Fix: read transient arguments while the transient is active — e.g. call (transient-args 'kanban-properties) inside the suffix command, build the property functions there, and pass them down to the update code instead of calling transient-args deep inside.
- edebug gotcha: edebug only breaks if you instrument the actual runtime function. For transient suffixes:
  - Evaluate the suffix so the defun exists, then run M-x edebug-instrument-function RET <suffix-fn> RET (or use (debug-on-entry '...)).
  - Then invoke the transient and press the suffix key; edebug will stop and you can inspect args.
- Quick notes: messages show because the function ran; if edebug didn't stop you probably instrumented the wrong form or redefined the function after instrumenting.

#+end_example

*** replace property

There is something strange with this.

*** TODO No match
If the match is not set, it should't add "nil"
Actually it shouldnt create a transform function at all.



** TODO Make sure

** TODO Making a inifix with board names...


#+BEGIN: kanban :mirrored nil :match nil
| TODO                                | DONE                   |
|-------------------------------------+------------------------|
|                                     | [[file:README.org::*Jump to board (suffix)][Jump to board (suffix)]] |
| [[file:README.org::*add the heading to choices.][add the heading to choices.]]         |                        |
| [[file:README.org::*org element at point][org element at point]]                |                        |
|                                     | [[file:README.org::*Adding match property][Adding match property]]  |
|                                     | [[file:README.org::*Property update][Property update]]        |
| [[file:README.org::*No match][No match]]                            |                        |
| [[file:README.org::*Make sure][Make sure]]                           |                        |
| [[file:README.org::*Making a inifix with board names...][Making a inifix with board names...]] |                        |
#+END:

Bug fixing.
The first part is that we are sending =mirror= that is wrong it should be =:mirrored=
In [[file:kanban-transient.el::defun kanban-get-property-fn (property-name args][kanban-get-property-fn]] we use the =property-name= what we need to do is to get /switch/.
Though this is though, we need to remove the ~--.*=~
And make it a :mirrored




#+begin_src emacs-lisp
  (defun plist-to-string (plist)
    "Transform a plist into a string"
    (interactive "P")
    )


  (let* ((plist-str (concat ":mirror nil :match \"calle\""))
         (key (intern (concat ":" "match")))
         (val (intern "bajs"))

         (plist (car (read-from-string (concat "(" plist-str ")" ))))
         (updated (plist-put plist :match 'fisk))
         )
    (with-temp-buffer
      (prin1 plist (current-buffer))
      (buffer-string)
      )

    )

  ;; Maybe im doing this the wrong way.
  ;; Maybe evrything should be items, and then post-process the bloody thing.



#+end_src

#+RESULTS:
: (:mirror nil :match fisk)

** Emacs-lisp

If i have a plist for example =(:mirrored nil :match calle)=
and i need to print it out. I can use =prin1-to-string=.
then it becomes

#+begin_src emacs-lisp
  (let* ((plist '(:mirrored nil :match calle))
         )
    (substring (prin1-to-string plist) 1 -1)
    )

#+end_src


 ":mirrored nil :match calle"

The problem occurs that some of the values needs to be quouted. For example
in this case =:match "calle"= so the return string will be

#+begin_src emacs-lisp
  (let* ((plist '(:mirrored nil :match "calle"))
         (out (substring (prin1-to-string plist) 1 -1))
         )
    (insert "Out: %s" out)
    )

#+end_src

#+RESULTS:

":mirrored nil :match \"calle\""
